/**
  ******************************************************************************
  * @file    ws2812b.c
  * @author  Lichangchun
  * @version 0.1
  * @date    2-Jun-2019
  * @brief   WS2812B 全彩灯珠驱动
  *         硬件 SPI 模拟 WS2812B 时序, SPI 的 8 位数据表示 WS2812B 的 1 位
  *         STM32 主频 72 MHz, SPI 预分频 32, 则 SPI 一位数据传输时间为 444 ns
  *         那么 SPI 1 Byte 数据可以表示 WS2812B 的 8/3 bits, 所以 1 Byte(8 bits)
  *         单色数要用 3 Bytes SPI 数据表示
  ******************************************************************************
  */
  
/* Includes ------------------------------------------------------------------*/
#include "ws2812b.h"
#include "delay.h"
/* Private typedef -----------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/

/* Private variables ---------------------------------------------------------*/
// WS2812B 字节编码速查表
static uint8_t encoderLookup[256*3] = {	0x92,0x49,0x24,0x92,0x49,0x26,0x92,0x49,0x34,0x92,0x49,0x36,0x92,0x49,0xA4,0x92,0x49,0xA6,0x92,0x49,0xB4,0x92,0x49,0xB6,0x92,0x4D,0x24,0x92,0x4D,0x26,0x92,0x4D,0x34,0x92,0x4D,0x36,0x92,0x4D,0xA4,0x92,0x4D,0xA6,0x92,0x4D,0xB4,0x92,0x4D,0xB6,0x92,0x69,0x24,0x92,0x69,0x26,0x92,0x69,0x34,0x92,0x69,0x36,0x92,0x69,0xA4,0x92,0x69,0xA6,0x92,0x69,0xB4,0x92,0x69,0xB6,0x92,0x6D,0x24,0x92,0x6D,0x26,0x92,0x6D,0x34,0x92,0x6D,0x36,0x92,0x6D,0xA4,0x92,0x6D,0xA6,0x92,0x6D,0xB4,0x92,0x6D,0xB6,0x93,0x49,0x24,0x93,0x49,0x26,0x93,0x49,0x34,0x93,0x49,0x36,0x93,0x49,0xA4,0x93,0x49,0xA6,0x93,0x49,0xB4,0x93,0x49,0xB6,0x93,0x4D,0x24,0x93,0x4D,0x26,0x93,0x4D,0x34,0x93,0x4D,0x36,0x93,0x4D,0xA4,0x93,0x4D,0xA6,0x93,0x4D,0xB4,0x93,0x4D,0xB6,0x93,0x69,0x24,0x93,0x69,0x26,0x93,0x69,0x34,0x93,0x69,0x36,0x93,0x69,0xA4,0x93,0x69,0xA6,0x93,0x69,0xB4,0x93,0x69,0xB6,0x93,0x6D,0x24,0x93,0x6D,0x26,0x93,0x6D,0x34,0x93,0x6D,0x36,0x93,0x6D,0xA4,0x93,0x6D,0xA6,0x93,0x6D,0xB4,0x93,0x6D,0xB6,0x9A,0x49,0x24,0x9A,0x49,0x26,0x9A,0x49,0x34,0x9A,0x49,0x36,0x9A,0x49,0xA4,0x9A,0x49,0xA6,0x9A,0x49,0xB4,0x9A,0x49,0xB6,0x9A,0x4D,0x24,0x9A,0x4D,0x26,0x9A,0x4D,0x34,0x9A,0x4D,0x36,0x9A,0x4D,0xA4,0x9A,0x4D,0xA6,0x9A,0x4D,0xB4,0x9A,0x4D,0xB6,0x9A,0x69,0x24,0x9A,0x69,0x26,0x9A,0x69,0x34,0x9A,0x69,0x36,0x9A,0x69,0xA4,0x9A,0x69,\
										0xA6,0x9A,0x69,0xB4,0x9A,0x69,0xB6,0x9A,0x6D,0x24,0x9A,0x6D,0x26,0x9A,0x6D,0x34,0x9A,0x6D,0x36,0x9A,0x6D,0xA4,0x9A,0x6D,0xA6,0x9A,0x6D,0xB4,0x9A,0x6D,0xB6,0x9B,0x49,0x24,0x9B,0x49,0x26,0x9B,0x49,0x34,0x9B,0x49,0x36,0x9B,0x49,0xA4,0x9B,0x49,0xA6,0x9B,0x49,0xB4,0x9B,0x49,0xB6,0x9B,0x4D,0x24,0x9B,0x4D,0x26,0x9B,0x4D,0x34,0x9B,0x4D,0x36,0x9B,0x4D,0xA4,0x9B,0x4D,0xA6,0x9B,0x4D,0xB4,0x9B,0x4D,0xB6,0x9B,0x69,0x24,0x9B,0x69,0x26,0x9B,0x69,0x34,0x9B,0x69,0x36,0x9B,0x69,0xA4,0x9B,0x69,0xA6,0x9B,0x69,0xB4,0x9B,0x69,0xB6,0x9B,0x6D,0x24,0x9B,0x6D,0x26,0x9B,0x6D,0x34,0x9B,0x6D,0x36,0x9B,0x6D,0xA4,0x9B,0x6D,0xA6,0x9B,0x6D,0xB4,0x9B,0x6D,0xB6,0xD2,0x49,0x24,0xD2,0x49,0x26,0xD2,0x49,0x34,0xD2,0x49,0x36,0xD2,0x49,0xA4,0xD2,0x49,0xA6,0xD2,0x49,0xB4,0xD2,0x49,0xB6,0xD2,0x4D,0x24,0xD2,0x4D,0x26,0xD2,0x4D,0x34,0xD2,0x4D,0x36,0xD2,0x4D,0xA4,0xD2,0x4D,0xA6,0xD2,0x4D,0xB4,0xD2,0x4D,0xB6,0xD2,0x69,0x24,0xD2,0x69,0x26,0xD2,0x69,0x34,0xD2,0x69,0x36,0xD2,0x69,0xA4,0xD2,0x69,0xA6,0xD2,0x69,0xB4,0xD2,0x69,0xB6,0xD2,0x6D,0x24,0xD2,0x6D,0x26,0xD2,0x6D,0x34,0xD2,0x6D,0x36,0xD2,0x6D,0xA4,0xD2,0x6D,0xA6,0xD2,0x6D,0xB4,0xD2,0x6D,0xB6,0xD3,0x49,0x24,0xD3,0x49,0x26,0xD3,0x49,0x34,0xD3,0x49,0x36,0xD3,0x49,0xA4,0xD3,0x49,0xA6,0xD3,0x49,0xB4,0xD3,0x49,0xB6,0xD3,0x4D,0x24,0xD3,0x4D,0x26,0xD3,0x4D,0x34,0xD3,\
										0x4D,0x36,0xD3,0x4D,0xA4,0xD3,0x4D,0xA6,0xD3,0x4D,0xB4,0xD3,0x4D,0xB6,0xD3,0x69,0x24,0xD3,0x69,0x26,0xD3,0x69,0x34,0xD3,0x69,0x36,0xD3,0x69,0xA4,0xD3,0x69,0xA6,0xD3,0x69,0xB4,0xD3,0x69,0xB6,0xD3,0x6D,0x24,0xD3,0x6D,0x26,0xD3,0x6D,0x34,0xD3,0x6D,0x36,0xD3,0x6D,0xA4,0xD3,0x6D,0xA6,0xD3,0x6D,0xB4,0xD3,0x6D,0xB6,0xDA,0x49,0x24,0xDA,0x49,0x26,0xDA,0x49,0x34,0xDA,0x49,0x36,0xDA,0x49,0xA4,0xDA,0x49,0xA6,0xDA,0x49,0xB4,0xDA,0x49,0xB6,0xDA,0x4D,0x24,0xDA,0x4D,0x26,0xDA,0x4D,0x34,0xDA,0x4D,0x36,0xDA,0x4D,0xA4,0xDA,0x4D,0xA6,0xDA,0x4D,0xB4,0xDA,0x4D,0xB6,0xDA,0x69,0x24,0xDA,0x69,0x26,0xDA,0x69,0x34,0xDA,0x69,0x36,0xDA,0x69,0xA4,0xDA,0x69,0xA6,0xDA,0x69,0xB4,0xDA,0x69,0xB6,0xDA,0x6D,0x24,0xDA,0x6D,0x26,0xDA,0x6D,0x34,0xDA,0x6D,0x36,0xDA,0x6D,0xA4,0xDA,0x6D,0xA6,0xDA,0x6D,0xB4,0xDA,0x6D,0xB6,0xDB,0x49,0x24,0xDB,0x49,0x26,0xDB,0x49,0x34,0xDB,0x49,0x36,0xDB,0x49,0xA4,0xDB,0x49,0xA6,0xDB,0x49,0xB4,0xDB,0x49,0xB6,0xDB,0x4D,0x24,0xDB,0x4D,0x26,0xDB,0x4D,0x34,0xDB,0x4D,0x36,0xDB,0x4D,0xA4,0xDB,0x4D,0xA6,0xDB,0x4D,0xB4,0xDB,0x4D,0xB6,0xDB,0x69,0x24,0xDB,0x69,0x26,0xDB,0x69,0x34,0xDB,0x69,0x36,0xDB,0x69,0xA4,0xDB,0x69,0xA6,0xDB,0x69,0xB4,0xDB,0x69,0xB6,0xDB,0x6D,0x24,0xDB,0x6D,0x26,0xDB,0x6D,0x34,0xDB,0x6D,0x36,0xDB,0x6D,0xA4,0xDB,0x6D,0xA6,0xDB,0x6D,0xB4,0xDB,0x6D,0xB6};
uint8_t pixelBuffer[RGB_LED_NUM * 9] = {0};

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/*******************************************************************************
  * @brief  WS2812B 端口初始化
  * @param  None
  * @retval None
*******************************************************************************/
void RGB_LED_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  SPI_InitTypeDef  SPI_InitStructure;
  DMA_InitTypeDef DMA_InitStructure;
 
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //PORTA时钟使能 
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE); //SPI1时钟使能 	
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);	//使能DMA传输
  
  /* PA7  SPI1_MOSI */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //PA7复用推挽输出 SPI
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA
  
  SPI_InitStructure.SPI_Direction = SPI_Direction_1Line_Tx;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
  SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
  SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;		//设置SPI的数据大小:SPI发送接收8位帧结构
  SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;		//串行同步时钟的空闲状态为低电平
  SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;	//串行同步时钟的第2个跳变沿（上升或下降）数据被采样
  SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;		//定义波特率预分频的值:波特率预分频值为16
  SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
  SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
  SPI_Init(SPI1, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
 
  SPI_Cmd(SPI1, ENABLE); //使能SPI外设
  SPI_I2S_DMACmd(SPI1, SPI_I2S_DMAReq_Tx, ENABLE);
  
  DMA_DeInit(DMA1_Channel3);   //将DMA的通道1寄存器重设为缺省值
  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) &(SPI1 -> DR); //cpar;  //DMA外设ADC基地址
  DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)pixelBuffer; //cmar;  //DMA内存基地址
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;  //数据传输方向，从内存读取发送到外设
  DMA_InitStructure.DMA_BufferSize = RGB_LED_NUM * 9; //DMA通道的DMA缓存的大小
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  //外设地址寄存器不变
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  //内存地址寄存器递增
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  //数据宽度为8位
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte; //数据宽度为8位
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  //工作在正常缓存模式
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; //DMA通道 x拥有中优先级 
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  //DMA通道x没有设置为内存到内存传输
  DMA_Init(DMA1_Channel3, &DMA_InitStructure);  //根据DMA_InitStruct中指定的参数初始化DMA的通道DMA_Channel13所标识的寄存器 
  
  RGB_LED_Clear();  //关闭全部的灯
  delay_ms(100); //关闭全部的灯需要一定的时间 
}

/*******************************************************************************
  * @brief  WS2812B 更新显示一遍
  * @param  None
  * @retval None
*******************************************************************************/
void RGB_LED_Show(void)
{
  DMA_Cmd(DMA1_Channel3, DISABLE); //关闭USART1 TX DMA1 所指示的通道 
  DMA_ClearFlag(DMA1_FLAG_TC3);    
  DMA_SetCurrDataCounter(DMA1_Channel3, 9 * RGB_LED_NUM);//DMA通道的DMA缓存的大小
  DMA_Cmd(DMA1_Channel3, ENABLE);  //使能 DMA1_Channel3 所指示的通道
}

/*******************************************************************************
  * @brief  将三原色(RGB)合并为 24 位颜色数据
  * @param  r, g, b
  * @retval 颜色数据
*******************************************************************************/
uint32_t RGB_LED_Color(uint8_t r, uint8_t g, uint8_t b)
{
  return (uint32_t)r << 16 | (uint32_t)g << 8 | b;
}

/*******************************************************************************
  * @brief  WS2812B 关闭所有灯珠
  * @param  None
  * @retval None
*******************************************************************************/
void RGB_LED_Clear(void)
{
  uint16_t i;
  uint8_t j;
  for (i = 0; i < RGB_LED_NUM * 9; i+=3)
  {
    for (j = 0; j < 3; j++)
    {
      pixelBuffer[i + j] = encoderLookup[0 + j];
    }
  }
  RGB_LED_Show();
}

/*******************************************************************************
  * @brief  通过 RGB 设置第 n 个灯珠颜色
  * @param  n 灯珠位置
  *         r 红色数值
  *         g 绿色数值
  *         b 蓝色数值
  * @retval None
*******************************************************************************/
void RGB_LED_SetPixelRGB(uint16_t n, uint8_t r, uint8_t g, uint8_t b)
{
  uint8_t i;
  // 每个像素点(灯珠)对应缓冲区中的 9 位, G, R, B 各占三位
  // Green -> Red -> Blue
  for (i = 0; i < 3; i++)
  {
    pixelBuffer[n * 9 + i] = encoderLookup[g + i];
  }
  for (i = 0; i < 3; i++)
  {
    pixelBuffer[n * 9 + i + 3] = encoderLookup[r + i];
  }
  for (i = 0; i < 3; i++)
  {
    pixelBuffer[n * 9 + i + 6] = encoderLookup[b + i];
  }
}

/*******************************************************************************
  * @brief  设置第 n 个灯珠颜色
  * @param  color 颜色数值
  * @retval None
*******************************************************************************/
void RGB_LED_SetPixelColor(uint16_t n, uint32_t color)
{
  uint8_t r = (color >> 16) | 0xFF;
  uint8_t g = (color >> 8) | 0xFF;
  uint8_t b = color | 0xFF;
  RGB_LED_SetPixelRGB(n, r, g, b);
}

/**************** 移植 Adafruit_NeoPixel 的库函数部分 *************************/

/*******************************************************************************
  * @brief  获取按 r - g - b - r 轮转的颜色数值
  * @param  wheelPos 0~255 的数值用以获取颜色数值
  * @retval 颜色数值
*******************************************************************************/
uint32_t RGB_LED_Wheel(uint8_t wheelPos) 
{
  wheelPos = 255 - wheelPos;
  if(wheelPos < 85) 
  {
    return RGB_LED_Color(255 - wheelPos * 3, 0, wheelPos * 3);
  }
  if(wheelPos < 170) 
  {
    wheelPos -= 85;
    return RGB_LED_Color(0, wheelPos * 3, 255 - wheelPos * 3);
  }
  wheelPos -= 170;
  return RGB_LED_Color(wheelPos * 3, 255 - wheelPos * 3, 0);
}

/*******************************************************************************
  * @brief  用颜色依次填充每个点
  * @param  c 要填充的颜色
  *         wait 间隔时间, ms
  * @retval None
*******************************************************************************/
void RGB_LED_ColorWipe(uint32_t c, uint8_t wait)
{
  for(uint16_t i=0; i < RGB_LED_NUM; i++) 
  {
    RGB_LED_SetPixelColor(i, c);
    RGB_LED_Show();
    delay_ms(wait);
  }
}

/*******************************************************************************
  * @brief  显示彩虹效果
  * @param  wait 间隔时间, ms
  * @retval None
*******************************************************************************/
void RGB_LED_Rainbow(uint8_t wait) 
{
  uint16_t i, j;

  for(j = 0; j < 256; j++) 
  {
    for(i = 0; i < RGB_LED_NUM; i++) 
    {
      RGB_LED_SetPixelColor(i, RGB_LED_Wheel((i+j) & 255));
    }
    RGB_LED_Show();
    delay_ms(wait);
  }
}

/*******************************************************************************
  * @brief  均匀分布的彩虹效果
  * @param  wait 间隔时间, ms
  * @retval None
*******************************************************************************/
void RGB_LED_RainbowCycle(uint8_t wait) 
{
  uint16_t i, j;
  
  for(j = 0; j < 256 * 5; j++) 
  { // 5 cycles of all colors on wheel
    for(i = 0; i < RGB_LED_NUM; i++) 
    {
      RGB_LED_SetPixelColor(i, RGB_LED_Wheel(((i * 256 / RGB_LED_NUM) + j) & 255));
    }
    RGB_LED_Show();
    delay_ms(wait);
  }
}

/*******************************************************************************
  * @brief  影院风格
  * @param  c 要填充的颜色
  *         wait 间隔时间, ms
  * @retval None
*******************************************************************************/
void RGB_LED_TheaterChase(uint32_t c, uint8_t wait) 
{
  for (int j = 0; j < 10; j++) 
  {  //do 10 cycles of chasing
    for (int q = 0; q < 3; q++) 
    {
      for (uint16_t i = 0; i < RGB_LED_NUM; i=i+3) 
      {
        RGB_LED_SetPixelColor(i + q, c);//turn every third pixel on
      }
      RGB_LED_Show();
      
      delay_ms(wait);
      
      for (uint16_t i=0; i < RGB_LED_NUM; i=i+3) 
      {
        RGB_LED_SetPixelColor(i+q, 0);//turn every third pixel off
      }
    }
  }
}

/*******************************************************************************
  * @brief  带彩虹效果的影院爬行灯
  * @param  wait 间隔时间, ms
  * @retval None
*******************************************************************************/
void RGB_LED_TheaterChaseRainbow(uint8_t wait) {
  for (int j = 0; j < 256; j++) 
  {     // cycle all 256 colors in the wheel
    for (int q = 0; q < 3; q++) 
    {
      for (uint16_t i = 0; i < RGB_LED_NUM; i = i + 3) 
      {
        RGB_LED_SetPixelColor(i + q, RGB_LED_Wheel( (i + j) % 255));    //turn every third pixel on
      }
      RGB_LED_Show();
      
      delay_ms(wait);
      
      for (uint16_t i = 0; i < RGB_LED_NUM; i = i + 3)
      {
        RGB_LED_SetPixelColor(i + q, 0); //turn every third pixel off
      }
    }
  }
}
